/* Generated by Together */
//SQLHSTMT  m_stmt 从成员变量修改为成员数组变量。
//setSql的调用最好放在循环体外部
#ifndef ALTIBASEINTF_H
#define ALTIBASEINTF_H
#include <string>
#include <iostream>
#include <time.h>
#include <sqlcli.h>
#include <vector>
#include "base/exceptions.h"

const int MaxShmtCnt = 20;  

DECLARE_EXCEPTION(AltibaseException, PrimalException);

#ifndef AIX
typedef long _int64;
#endif


namespace abdb
{
    
using std::string;
using std::vector;    



/** Altibase数据库接口类 */
class AltibaseIntf {

    
public:
    
    AltibaseIntf();

    ~AltibaseIntf();

//add by xuf for debug 2007-12-3 14:38 
//    void debug_log(const char *sql, char *strBuf);
    
    /** 是否已成功连接数据库 */
    inline bool isConnected() { return m_connected; };

    /** 重新连接数据库 */
    void reConnect();

    /** 连接数据库 */
    void connect();

    /** 断开数据库 */
    void disConnect();

    /** 提交事务 */
    inline void commit() {
        if (m_connected) {
            SQLTransact(m_env, m_dbc, SQL_COMMIT);
            m_intran = false;
        }
    };

    /** 回滚事务 */
    inline void rollback() {
        if (m_connected) {
            SQLTransact(m_env, m_dbc, SQL_ROLLBACK);
            m_intran = false;
        }
    };

    /** 设置将要执行的sql语句 */
//    void setSql(const string & sql);//2007-12-3 11:16
    SQLHSTMT   setSql(const string & sql);

    /** 设置按行绑定方式执行 */
    void setArrayBindByRow(SQLHSTMT  stmt,unsigned int rowSize,unsigned int rowCount)
    {
        m_status = new SQLUSMALLINT[rowCount];
        m_processed = new SQLUINTEGER(0);
        
        SQLSetStmtAttr(stmt, SQL_ATTR_PARAM_BIND_TYPE, (void*)rowSize, 0);
        SQLSetStmtAttr(stmt, SQL_ATTR_PARAMSET_SIZE, (void*)rowCount, 0);
        SQLSetStmtAttr(stmt, SQL_ATTR_PARAMS_PROCESSED_PTR,(void*)m_processed, 0);
        SQLSetStmtAttr(stmt, SQL_ATTR_PARAM_STATUS_PTR, (void*)m_status, 0);    
    }

    /** 设置string绑定变量 */
    inline void setString(SQLHSTMT  stmt,unsigned int paramIndex, const string & x, const SQLSMALLINT pType =  SQL_PARAM_INPUT) 
    {
        if (SQLBindParameter(stmt, paramIndex, pType,SQL_C_CHAR, SQL_VARCHAR,x.length(),
                         0, (void *)x.c_str(), x.length(), NULL) != SQL_SUCCESS)
        {
            throwError(stmt,"绑定变量出错：");
        }        
        
    };

    inline void setString(SQLHSTMT  stmt,unsigned int paramIndex, char * x, int maxSize,const SQLSMALLINT pType =  SQL_PARAM_INPUT) 
    {
        if (SQLBindParameter(stmt, paramIndex, pType,SQL_C_CHAR, SQL_VARCHAR,maxSize,
                         0, (void *)x, sizeof(x), NULL) != SQL_SUCCESS)
        {
            throwError(stmt,"绑定变量出错：");
        }        
        
    };
        
    /** 设置int绑定变量 */
    inline void setInt(SQLHSTMT  stmt,unsigned int paramIndex, const int & x,const SQLSMALLINT pType =  SQL_PARAM_INPUT) {
        if (SQLBindParameter(stmt, paramIndex, pType,SQL_C_SLONG, SQL_INTEGER,sizeof(int),
                         0, (void *)&x, 0, NULL) != SQL_SUCCESS)
        {
            throwError(stmt,"绑定变量出错：");
        }                  
    };
    
    inline void setShort(SQLHSTMT  stmt,unsigned int paramIndex, const short & x,const SQLSMALLINT pType =  SQL_PARAM_INPUT) {
        if (SQLBindParameter(stmt, paramIndex, pType,SQL_C_SSHORT, SQL_SMALLINT,sizeof(short),
                         0, (void *)&x, 0, NULL) != SQL_SUCCESS)
        {
            throwError(stmt,"绑定变量出错：");
        }                  
    };
        
     /** 设置double绑定变量 */
    inline void setDouble(SQLHSTMT  stmt,unsigned int paramIndex, const double &x,const SQLSMALLINT pType =  SQL_PARAM_INPUT) {
        if (SQLBindParameter(stmt, paramIndex, pType,SQL_C_DOUBLE, SQL_NUMERIC,20,
                         3, (void *)&x, 0, NULL) != SQL_SUCCESS)
        {
            throwError(stmt,"绑定变量出错："); 
        }                  
    };

     /** 设置Date绑定变量 */
    inline void setDate(SQLHSTMT  stmt,unsigned int paramIndex, const SQL_TIMESTAMP_STRUCT &x,const SQLSMALLINT pType =  SQL_PARAM_INPUT) 
    {
        if (SQLBindParameter(stmt, paramIndex, pType,SQL_C_TYPE_TIMESTAMP, SQL_DATE,
                         sizeof(SQL_TIMESTAMP_STRUCT), 0, (void *)&x, 0, NULL) != SQL_SUCCESS)
        {
            throwError(stmt,"绑定变量出错："); 
        } 
    }
    
    /** 获取字符串字段数值 */
    inline string getString(unsigned int paramIndex) {
        if (m_rs->m_columnDataType[paramIndex-1] == SQL_NUMERIC)
        {
            char buff[64];
            sprintf(buff,"%f",*(double *)m_rs->m_columnPtr[paramIndex-1]);
            return string(buff);
        }
        else
            return string((char *)m_rs->m_columnPtr[paramIndex-1]);
    };

    /** 获取整数字段数值 */
    inline int getInt(unsigned int paramIndex) {
        if (m_rs->m_columnDataType[paramIndex-1] == SQL_SMALLINT)
            return *(short*)m_rs->m_columnPtr[paramIndex-1];  
        else
            return *(int*)m_rs->m_columnPtr[paramIndex-1]; 
    };
    
    /** 获取不超过15位的numberic字段数值 */
    inline double getDouble(unsigned int paramIndex) {
        return *(double*)m_rs->m_columnPtr[paramIndex-1];
    };

    /** 获取日期字段数值 */
    inline string getDate(unsigned int paramIndex, char * fmt="%4d-%02d-%02d %02d:%02d:%02d") {
        char buff[32];
        sprintf(buff,fmt,
                        ((SQL_TIMESTAMP_STRUCT*)m_rs->m_columnPtr[paramIndex-1])->year,
                        ((SQL_TIMESTAMP_STRUCT*)m_rs->m_columnPtr[paramIndex-1])->month,
                        ((SQL_TIMESTAMP_STRUCT*)m_rs->m_columnPtr[paramIndex-1])->day,
                        ((SQL_TIMESTAMP_STRUCT*)m_rs->m_columnPtr[paramIndex-1])->hour,
                        ((SQL_TIMESTAMP_STRUCT*)m_rs->m_columnPtr[paramIndex-1])->minute,
                        ((SQL_TIMESTAMP_STRUCT*)m_rs->m_columnPtr[paramIndex-1])->second);    
        
        return string(buff);
    };

        /** 获取长整数字段数值 */
    inline _int64 getLong(unsigned int paramIndex) {
            return *(_int64*)m_rs->m_columnPtr[paramIndex-1]; 
    };

    /** 获取将要执行的sql语句 */
    string getsql() const;

    /** 执行查询语句 */
//   void execQuery();

    /** 执行查询语句 */
//    void execQuery(const string & sql);
    
    void execQuery(SQLHSTMT  stmt,const string & sql);
    
    /** 执行存储过程 */
 //   void execProc();
    void execProc(SQLHSTMT  stmt,const string & sql);
    
    /** 执行修改、删除、插入语句 */
//    unsigned int execUpdate();
    unsigned int execUpdate(SQLHSTMT  stmt,const string & sql); //2007-12-3 11:22
    

    /** 获取查询结果集的下一条记录 */
    bool next()
    { 
        if (m_rs) return m_rs->fetch(); 
        return false;
    }
    

    /** 获取数据库接口句柄*/
    static AltibaseIntf * getInstance();

    /** 设置连接信息 */
    void setConnInfo(const string & uid, const string & pwd, const string & dsn,const string & portNo);


    /* 获取连接的时长，单位为秒*/
    long getConnectedTime();
    
    /** 强制重新连接 */
    bool forceReConnect(string & errorInfo);
    
    
    class ResultSet
    {
        friend class AltibaseIntf;
        public:
            ResultSet(SQLHSTMT stmt)
            {
                m_stmt = stmt;
                SQLNumResultCols(m_stmt, &m_columnCount);
    
                m_columnPtr = (void**) malloc( sizeof(void*) * m_columnCount );
                
                if ( m_columnPtr == NULL )
                {
                    THROW(AltibaseException, "分配内存失败(columnPtr)。"); 
                }
    
                m_columnInd = (SQLINTEGER*) malloc( sizeof(SQLINTEGER) * m_columnCount );
                
                m_columnDataType.clear();
                for (int i=0; i<m_columnCount; i++ )
                {
                    SQLDescribeCol(m_stmt, i+1,m_columnName, sizeof(m_columnName), &m_columnNameLength,&m_dataType, &m_columnSize, &m_scale, &m_nullable);
                    m_columnDataType.push_back(m_dataType);
                    switch (m_dataType)
                    {
                    case SQL_CHAR:
                        m_columnPtr[i] = (char*) malloc( m_columnSize + 1 );
                        SQLBindCol(m_stmt, i+1, SQL_C_CHAR, m_columnPtr[i], m_columnSize+1, &m_columnInd[i]);
                        break;
                    case SQL_VARCHAR:
                        m_columnPtr[i] = (char*) malloc( m_columnSize + 1 );
                        SQLBindCol(m_stmt, i+1, SQL_C_CHAR, m_columnPtr[i], m_columnSize+1, &m_columnInd[i]);
                        break;
                    case SQL_INTEGER:
                        m_columnPtr[i] = (int*) malloc( sizeof(int) );
                        //SQLBindCol(m_stmt, i+1, SQL_C_SLONG, m_columnPtr[i], 0, &m_columnInd[i]);
                        SQLBindCol(m_stmt, i+1, SQL_C_SLONG, m_columnPtr[i], sizeof(int), NULL);
                        break;
                    case SQL_SMALLINT:
                        m_columnPtr[i] = (short*) malloc( sizeof(short) );
                        SQLBindCol(m_stmt, i+1, SQL_C_SSHORT, m_columnPtr[i], 0, &m_columnInd[i]);
                        break;
                    case SQL_NUMERIC:
                        m_columnPtr[i] = (double*) malloc( sizeof(double) );
                        SQLBindCol(m_stmt, i+1, SQL_C_DOUBLE, m_columnPtr[i], 0, &m_columnInd[i]);
                        break;
                    case SQL_DATE:
                        m_columnPtr[i] = (SQL_TIMESTAMP_STRUCT*) malloc( sizeof(SQL_TIMESTAMP_STRUCT) );
                        SQLBindCol(m_stmt, i+1, SQL_C_TYPE_TIMESTAMP, m_columnPtr[i], 0, &m_columnInd[i]);
                        break;
                    case SQL_BIGINT:
                        m_columnPtr[i] = (_int64*) malloc( sizeof(_int64) );
                        SQLBindCol(m_stmt, i+1, SQL_C_SBIGINT, m_columnPtr[i], sizeof(_int64), NULL);
                        break;
                     default:   
                         m_columnPtr[i] = (int*) malloc( sizeof(int) );
                         SQLBindCol(m_stmt, i+1, SQL_C_SLONG, m_columnPtr[i], sizeof(int), NULL);
                    }
                }                
            }
            ~ResultSet()
            {
                for (int i=0; i<m_columnCount; i++ )
                {
                    free( m_columnPtr[i] );
                }
                
                free( m_columnPtr );
                free( m_columnInd );  
    
            }
            bool fetch()
            {
                return ( SQLFetch(m_stmt) == SQL_SUCCESS);
            }    
        private:
            SQLHSTMT  m_stmt;
            SQLSMALLINT  m_columnCount;
            char         m_columnName[50];
            SQLSMALLINT  m_columnNameLength;
            SQLSMALLINT  m_dataType;
            SQLSMALLINT  m_scale;
            SQLSMALLINT  m_nullable;
            SQLUINTEGER  m_columnSize;

            void       **m_columnPtr;
            SQLINTEGER  *m_columnInd;   
            vector<SQLSMALLINT> m_columnDataType;          
        
    };

//    SQLHSTMT  m_stmt; //2007-12-3 10:53
      SQLHSTMT  m_stmtAry[MaxShmtCnt];  
      int    m_shmNum; 
private:

    /** 环境句柄 */
    SQLHENV  m_env; 
     
    /** 连接句柄 */
    SQLHDBC  m_dbc;

    /** 查询语句返回的结果集 */
    ResultSet * m_rs;

    /** 是否已经建立数据库连结 */
    bool m_connected;
    
    /** 释放相关资源 */
    void freeHandle();

    /** 是否在事务中 */
    bool m_intran;

    /** 建立数据库连结的时间 */
    time_t m_connected_time;

    /** 存放需要执行的sql语句 */
   // string m_sql; //2007-12-3 11:05

    /** 数据库用户 */
    string m_uid;

    /** 数据库密码 */
    string m_pwd;

    /** 主机IP */
    string m_dsn;
    
    /** 主机端口 */
    string m_portNo;
    
    /** 错误信息编码 */
    SQLINTEGER m_errNo;
    
    /** 错误信息长度 */
    SQLSMALLINT m_msgLength;
    
    /** 错误信息 */
    SQLCHAR m_errMsg[SQL_MAX_MESSAGE_LENGTH + 1];    
    
    /** 初始化 */
    bool init();
    
    /** 关闭查询结果集 */
    void closeResultSet(); 
    
    /** 处理出错信息 */
    bool getLastError(SQLHSTMT  stmt); //2007-12-3 13:48
    
    /** 抛出异常 */
    void throwError(SQLHSTMT  stmt,const char * msg);
    
    SQLUSMALLINT * m_status;
    SQLUINTEGER * m_processed;

};
}// namespace
#endif //ALTIBASEINTF_H
